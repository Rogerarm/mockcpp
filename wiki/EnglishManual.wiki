#labels Manual,English,Featured
=Work in progress=

=1. Background =

mock++ is a C/C++ mocking framework. It's neither a reinvention of the wheel nor Yet Another C++ Mocking Framework.

Before we started developing mock++, the only framework we could find on the Internet was mockpp. And it's the only option when we were
practicing agile. Though mockpp is an excellent framework, the long compilation time and obscure compilation error messages
resulted from the use of over sophisticated template was playing a negative role in our TDD practice. In addition, some features we needed
were missing in mockpp. Then we decided to develop a new framework after our failed attempt to extend it due to its complexity.

mock++ tries to meet these goals:

    * Using template as less as possible to boost compilation speed, reduce obscurity of error message.
    * The error messages emitted from the framework should be easy to understand, complete to help developers identify the problems quickly.
    * Mock objects are easy to create.
    * Extensibility to meet unique needs.
    * Ability to mock free function.

mock++ is largely inspired by [http://mockpp.sourceforge.net/ mockpp], [http://www.jmock.org/ jmock].

=2. Introcution =

mock++ currently supports following constraints / actions:

    # Matching call count -- {{{expects() / stubs()}}}
    # Matching caller -- {{{caller()}}}
    # Expectation order --- {{{before()}}}
    # Matching arguments -- {{{with()}}}
    # Expectation order --- {{{after()}}}
    # Setting actions -- {{{will() / then()}}}
    # Assigning an identifier -- {{{id()}}}

Except for expects() / stubs(), other constraints / actions are optional and should appear in the order below:
{{{
mock.method(&Interface::method)
      .expects(once())
      .before(anotherMock, "close")
      .with(eq(1), any(), neq(2.0))
      .after(anotherMock, "open")
      .will(returnValue(true))
      .then(throws(std::exception))
      .id("myMethod");
}}}

== Using Actions ==

===Purpose===

Actions play important roles in mocking framework and are the most fundamental value provided by mocking frameworks. Through actions, mocks act as stubs, yet in a better way.

===Types of Actions===

  * Returning a value:  {{{returnValue(value)}}}
  * Returning more than one values: {{{returnObjectList(o1, o2, ...)}}}
  * Throwing an exception: {{{throws(exception)}}}
  * Ignoring return value: {{{ignoreReturnValue()}}}
  * Delegating to a stub method: {{{invoke(stubFucntion)}}}
  * Returning a value repeatly: {{{repeat(value, times)}}}
  * Incrementing a value: {{{increase(from, to) / increase(from)}}}

===Usage===

To specify actions, use {{{will(behavior) / then(behavior)}}}. {{{will()}}} must be called before {{{then()}}} and can be called only once whereas {{{then()}}} multiple times.
{{{
     mock.method(&Interface::foo)
                .stubs()
                .will(returnValue(10))
                .then(repeat(20, 2))
                .then(throws(std::exception))
                .then(returnValue(5));
}}}
When using will()/then(), the specified actions will take effect in the order specified. In case of the number of calls is greater than the number of actions, the
last action will be used for any additional calls as long as the constraints are meet. The following assertion are true given the mock specification above, for instance.

returnValue() is used to set value to be returned when the mocked method is called. If it's the last action specified, the value will be returned on all method calls. If it's not, that value will be used only once.

You might want to return different values for the same method call. To do this, use returnObjectList(). mockcpp will return each of value specified in returnObjectList() in turn. If returnObjectList() is the last action, mockcpp will issue an error if the mocked method is called and the values have been used. If it's not, the action following it will take effect. In addition, the number of values supported by returnObjectList is limited. It might be a problem under some circumstance. To workaround this, use then() since it can be called any number of times.

To throw an exception, use throws(exception) even the method's return type of is void. When the method's return type is not void, an action must be specified even the return value is uninterested.


Usage


To specify arguments we are expecting, use with(contraint1, contraint2, …), where the constraints should be in the same order as in the method prototype. You can also use any() to ignore a argument. Calls to any() following the last non-ignoring constraints can be omitted.


For eq() and neq(), an compilation error will be thrown if equality test is not supported by the given type. To fix this, Add this capability by overloading '=='.

mirror is to constrain the content of a memory block. size argument can be ignored if it's used in object content comparison.

Note that when testing object content. the random padding bytes used to adjust object alignment can sometimes cause error. in C, you can use memset to set those bytes to 0. In C++, same effect can be achieved by using eq() on object whose '==' operator is overloaded.


startWith()，endWith(), contains() are used to constrain a string. startWith() tests if a string starts with the specified prefix, endWith() tests if a string ends with the specified prefix. Now you can guess what contains() means.

smirror is to test if a string equals to the specifed one. It's special implementation of mirror(). They only differ in that for smirror(), size can be calculated by mockcpp hence programmer is free from providing it. In addition, smirror() doesn't have the padding issue.


For output argument, 