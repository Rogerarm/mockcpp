==1. Default behavior==

Default behavior is defined by using _*defaults()*_, instead of _*expects()/stubs()*_. Relations between _*defaults()*_ and _*expects()/stubs()*_ could be thought as relations between *default* and *case* in C/C++ *switch* sentences. If all mock specifications of a method of a mock object specified with _*expects()/stubs()*_ don't match one of your invocations to the method in question, the specification defined with _*defaults()*_ (if have any) will be used to perform the return behavior. 

This is a very useful feature. It helps you write your tests in a neater way.  

{{{
class TestTestFilter: public CxxTest::TestSuite
{
private:

      MockObject<TestCaseInfoReader> testcase;

      TestFilter* filter;

public:
      void setUp()
      {
            filter = new TestFilter("*TestFixture", "testcase?");

            testcase.METHOD(TestCaseInfoReader::getCaseName)
                            .defaults().will(returnValue("testcase1"));

            testcase.METHOD(TestCaseInfoReader::getFixtureName)
                            .defaults().will(returnValue("FooTestFixture"));
      }

     void tearDown()
     {
           testcase.reset();

           delete filter;
     }

     void test_should_be_able_to_recoginize_matched_fixture()
     {
          TS_ASSERT_TRUE(filter->matches(testcase));
     }

     void test_should_tell_unmatched_if_test_fixture_name_does_not_match()
     {
          fixture.METHOD(TestFixtureInfoReader::getFixtureName)
             .stubs().will(returnValue("FooFixture"));

          TS_ASSERT_FALSE(filter->matches(testcase));
     }

     void test_should_tell_unmatched_if_testcase_name_does_not_match()
     {
          fixture.METHOD(TestFixtureInfoReader::getCaseName)
             .stubs().will(returnValue("testcase10"));

          TS_ASSERT_FALSE(filter->matches(testcase));
     }
};

}}}

In this example, the default behaviors of method getFixtureName() and getCaseName() are return matched names. So the first test case is to test the happy path. Pretty simple, you only need to write one assertion to test the class *TestFilter*. The latter 2 test cases test the unmatched cases, so  stubs() is used in each test case to "hide" the default behavior to do the exceptional test.

Furthermore, for one method, you can specify more than one default behavior, distinguished by _*with()*_ selectors. When falling in default category, mockcpp will try to select a matched default behavior. If multiple default behaviors match your invocation, the first one will be selected. In current implementation, the first matched one defined in a test is the one is chosen by mockcpp, but this might change in later version, so don't make your tests rely on this, instead, you should make your default specification distinguiable.