==1. Default behavior==

Default behavior is defined by using _*defaults()*_, instead of _*expects()/stubs()*_. Relations between _*defaults()*_ and _*expects()/stubs()*_ could be thought as relations between *default* and *case* in C/C++ *switch* sentences. If all mock specifications of a method of a mock object specified with _*expects()/stubs()*_ don't match one of your invocations to the method in question, the specification defined with _*defaults()*_ (if have any) will be used to perform the return behavior. 

This is a very useful feature. It helps you write your tests in a neater way.  

{{{

struct TestCaseInfoReadder
{
      virtual const std::string& getCaseName() const = 0;
      virtual const std::string& getFixtureName() const = 0;

      virtual ~TestCaseInfoReadder() {}
};

class TestGeneralTestFilter: public CxxTest::TestSuite
{
      MockObject<TestCaseInfoReader> testcase;

      GeneralTestFilter* filter;

public:

      void setUp()
      {
            filter = new GeneralTestFilter("*TestFixture", "testcase?");

            testcase.METHOD(TestCaseInfoReader::getCaseName)
                            .defaults().will(returnValue("testcase1"));

            testcase.METHOD(TestCaseInfoReader::getFixtureName)
                            .defaults().will(returnValue("FooTestFixture"));
      }

     void tearDown()
     {
           testcase.reset();

           delete filter;
     }

     void test_should_be_able_to_recoginize_matched_fixture()
     {
          TS_ASSERT_TRUE(filter->matches(testcase));
     }

     void test_should_tell_unmatched_if_test_fixture_name_does_not_match()
     {
          fixture.METHOD(TestFixtureInfoReader::getFixtureName)
             .stubs().will(returnValue("FooFixture"));

          TS_ASSERT_FALSE(filter->matches(testcase));
     }

     void test_should_tell_unmatched_if_testcase_name_does_not_match()
     {
          fixture.METHOD(TestFixtureInfoReader::getCaseName)
             .stubs().will(returnValue("testcase10"));

          TS_ASSERT_FALSE(filter->matches(testcase));
     }
};

}}}

In this example, the default behaviors of method getFixtureName() and getCaseName() are return matched names. So the first test case is to test the happy path. Pretty simple, you only need to write one assertion to test the class *`TestFilter`*. The latter 2 test cases test the unmatched cases, so in each test case the *stubs()* is used to "HIDE" the default behavior in order to do exceptional tests.

Furthermore, for one method, you can specify more than one default behavior, distinguished by _*with()*_ selectors. When falling in default category, mockcpp will try to select a matched default behavior. If multiple default behaviors match your invocation, the first one will be selected. In current implementation, the first matched one defined in a test is the one is chosen by mockcpp, but this might change in later version, so don't make your tests rely on this, instead, you should make your default specification distinguiable.

{{{

struct TestFilter
{
      virtual bool matches(TestCaseInfoReader* ) const = 0;

      virtual ~TestFilter() {}
};

struct TestCase : public TestCaseInfoReader
{
      virtual void run() throw (AssertionFailure) = 0;

      virtual ~TestCase() {}
};

class TestTestCaseRunner: public CxxTest::TestSuite
{
      MockObject<TestFilter> filter;
      MockObject<TestCase> testcase;

      TestRunner* runner;

public:
      void setUp()
      {
            runner = new SandboxTestRunner();

            filter.METHOD(TestFilter::matches)
                    .defaults()
                    .with(eq((TestCase*)testcase)
                    .will(returnValue(true));

            filter.METHOD(TestFilter::matches)
                    .defaults()
                    .with(neq((TestCase*)testcase)
                    .will(returnValue(false));
      }

     void tearDown()
     {
           filter.reset();
           testcase.reset();

           delete runner;
     }

     void test_should_run_matched_test_cases()
     {
           testcase.METHOD(TestCase::run).expects(once());

           runner->run(testcase, filter);

           testcase.verify();
     }

     void test_should_not_run_unmatched_test_cases()
     {
          MockObject<TestCase> unmatchedTestCase;
         
          unmatchedTestCase.METHOD(TestCase::run)
                  .expects(never());

           runner->run(unmatchedTestCase, filter);

           unmatchedTestCase.verify();
     }

     void test_should_throw_an_AsstionFailure_exception_if_the_test_case_did_that()
     {
           testcase.METHOD(TestCase::run)
                 .stubs().will(throws(AssertionFailure("AssertionFailure"));

           TS_ASSERT_THROWS(runner->run(testcase, filter), AssertionFailure);
     }

     void test_should_throw_a_CrashException_if_the_test_case_crashed()
     {
           testcase.METHOD(TestCase::run)
                 .stubs().will(die());

           TS_ASSERT_THROWS(runner->run(testcase, filter), CrashException);
     }
};

}}}

In this example, we used *defaults()* to specify the matched test case and unmatched test cases. It helps us to focus on the aspects which we intent to test in later test cases.

==2. Multiple Inheritance ==

In order to make mockcpp support multi-inheritance, you need to make sure the configure option *--disable-multi-inheritance* was not specified when you built mockcpp. Beside, you also need to be sure the interface you are trying to mock does not inherit from more than *N* other interfaces, and the *N* represents "allowed maximum number of inherited interfaces" of an interface. It was specified with the configure option *max_inheritance=N* at the building time. Currently, the default value is 2, and maximum allowed value is 5. If your interface inherits from more than that, you should probablly reconsider your design, or you are not able to mock it. The reason we chose this number was not technically,  but, according to our experience, when an interface needs to inherit from many other interfaces, usually it implies a *bad smell*. 

The similar constraint exists in the setting of maximum allowed methods in one interface, which is specified with the configure option *max_vtbl_size=N* (N cannot be specfied as the number more than 50, and its default value is 20). Note that the method number includes all methods defined in an interface and all its parents, normal methods and destructors. If an interface contains more than 50 ( still too many, in our opinion), probablly it's too fat -- taking too many responsibilities.

Sorry, I lied. It has technical reasons of having these constraints. Due to the usage of C++ template (we have tried our best to reduce it) in our implementation, the compiling time and generated binary size will increase with the growth of values of these settings. If you choose *max_inheritance=5* and *max_vtbl_size=50*, the compiling time would be far slower than specifying them as 2 and 20.

==3. Lifecycle Management==

==4. Resource Check Point==

==5. Dynamic Cast ==

mockcpp supports *dynamic_cast* quite well. The behavior of dynamic cast a mock object is exactly same as normal C++ object. 

Take an example:

{{{
////////////////////////////////////////////////////////////////
struct BillingObject
{
      enum Type
      {
          UNKNOWN = 0;
          CALL,
          SMS,
          INET
      };

      virtual Type getType() const = 0; 

      virtual ~BillingObject() {}
};

////////////////////////////////////////////////////////////////
struct Call : public BillingObject
{
      virtual const std::string& getPhoneNumberOfOriginator() const = 0;
      virtual const std::string& getPhoneNumberOfTerminator() const = 0;
      virtual unsigned int getDurationInSeconds() const = 0;

      virtual ~ShortMessage() {}
};

////////////////////////////////////////////////////////////////
struct InternetAccess : public BillingObject
{
      virtual const std::string& getPhoneNumber() const = 0;
      virtual unsigned int getDurationInSeconds() const = 0;
      virtual unsigned int getTransferSize() const = 0;

      virtual ~InternetAccess() {}
};

////////////////////////////////////////////////////////////////
struct Bill
{
     unsigned char type;
     std::string originator;
     unsigned int originatorFee;
     std::string terminator;
     unsigned int terminatorFee;
     unsigned int duration;
     unsigned int size;

     Bill() 
           : type(BillingObject::UNKOWN)
           , originator("")
           , originatorFee(0)
           , teminator("")
           , terminatorFee(0)
           , duration(0)
           , size(0)
     {}
};

////////////////////////////////////////////////////////////////
class BillingManager
{
public:

      void billing(const BillingObject* billingObject, Bill& bill);

// Other methods and attributes
};

}}} 

In this design, *billing()* always accepts an object of type BillingObject, but in its implementation, in order to generate bill correctly, it will be downcast to a concrete type according to the return value of method *getType()* .

Here is the test fixture for testing BillManager:

{{{

class TestBillingManager : public CxxTest::TestSuite
{
public:
 
     void test_should_be_able_to_generate_bill_of_a_CALL_type_billing_object()
     {
           BillingManager manager;
           Bill bill;

           MockObject<Call> billingObject;

           billingObject.METHOD(Call::getType)
                     .stubs().will(returnValue(BillingObject::CALL));

           billingObject.METHOD(Call::getPhoneNumberOfOriginator)
                     .stubs().will(returnValue(std::string("123456789")));

           billingObject.METHOD(Call::getPhoneNumberOfTerminator)
                     .stubs().will(returnValue(std::string("987654321")));

           billingObject.METHOD(Call::getDurationInSeconds)
                     .stubs().will(returnValue((unsigned int)78));
           
           manager.billing(billingObject, bill);

           TS_ASSERT_EQUALS(BillingObject::CALL, bill.type);
           TS_ASSERT_EQUALS("123456789", bill.originator);      
           TS_ASSERT_EQUALS("987654321", bill.terminator);      
           TS_ASSERT_EQUALS(78, bill.duration); 
           TS_ASSERT_EQUALS(0, bill.size); 
           TS_ASSERT_EQUALS(80, bill.originatorFee); 
           TS_ASSERT_EQUALS(20, bill.terminatorFee); 
     }
};

}}}

The CUT code:

{{{

void BillingManager::billing(const BillingObject* billingObject, Bill& bill)
{
      if(billingObject->getType() == BillingObject::CALL)
      {
            Call* call = dynamic_cast<Call*>(billingObject);
            // "call" should not be 0
            if(call == 0)
            {
                  throw Error("Invalid billing object");
            }

            bill.type = call->getType();
            bill.originator = call->getPhoneNumberOfOriginator();
            bill.terminator = call->getPhoneNumberOfTerminator();
            bill.duration = call->getDurationInSeconds();
            bill.size = 0;
            unsigned int minutes = (bill.duration/60 + (bill.duration%60>0?1:0));
            bill.originatorFee  = minutes* 40;
            bill.terminatorFee  = minutes* 10;
            return;
      }
      // Other code
};

}}}

Because the interface you mocked was *Call*, the parameter "pointer to billObject" of *billing()* could be successfully downcast to pointer to *Call*. If you specify the mocked interface as any other type, the downcast operation will return 0. 

In previous example, according the implmentation of the method *billing()*, the following test case will pass.

{{{
     void test_should_throw_an_Error_exception_if_the_object_type_mismatch()
     {
           BillingManager manager;
           Bill bill;

           MockObject<InternetAccess> billingObject;

           billingObject.METHOD(Call::getType)
                     .stubs().will(returnValue(BillingObject::CALL));
           
           TS_ASSERT_THROWS(manager.billing(billingObject, bill), Error);
     }
}}}

==6. Object Assignment==