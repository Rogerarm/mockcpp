#summary Handbook of mockcpp
#labels C,Mock,Mockcpp

= Introduction =

*mockcpp* is a light-weight C++ mock framework, compared with [http://mockpp.sourceforge.net mockpp]. *mockpp* uses complex template technique, which results in very heavy compiling and runtime overhead.

It's not reinventing wheels. Actually we've tried to use *mockpp* in several C++ agile projects. In practice, we compiled our unit test cases and check-in the code very frequently. As more unit test cases were producing, the compiling time and the size of target were increasing very quickly, which really discouraged the teams to do TDD.  

The goals of *mockcpp* are:
 * Use template as little as possbile to reduce compiling time and generated object size
 * Only the form of chaining mock is supported, since it is much preferred by us
 * Enhance it's functionalities
 * Make it easier to use:
   # You know how difficult to understand compiling error messages of complex template;
   # Once you got a runtime mocking error, the output information should help you find your problems very easily.
   # Creating a mock class should be very easy.

*mockcpp* is strongly enlightened by *mockpp* and [http://www.jmock.org jmock].

= How Do You Create A Mock Object =

To create a mock object, a mock class should be created first, which should be a sub-class of _ChainableMockObject .

{{{

class MockObject : public mockcpp::ChainableMockObject
{
public:
   MockObject()
      : mockcpp::ChainableMockObject("Object", 0)
   {}

   int foo(const char* p1, long p2, double p3)
   {
      return invoke<int>("foo")(p1, p2, p3);
   }

   void bar(const std::string& p1) const
   {
      invoke<void>("bar")(p1);
   }
};
 
}}}

Then you can create instances of this class and use it.

{{{
MockObject* mockObject = new MockObject;

mockObject->method("foo")
   .expects(once())
   .with(smirror("abc"), eq((long)10), eq(3.2))
   .will(returnValue(100));

CPPUNIT_ASSERT_EQUAL(100, mockObject->foo("abc", 10, 3.2));
}}}


= Behavior Spec =

Generally, once you hold a mock object, you can specify the its behavior by following expression:

{{{
mockObject.method(...)
     .expects(...)
     .before(...)
     .with(...)
     .after(...)
     .id(...);
}}}

The parameter of *method()* is a string which represents the method you are going to specify its behavior. 

*expects()* is used to specify the expected invocation times. Existing helper functions include:
 * once()
 * atLeast(unsigned int times)
 * atMost(unsigned int times)
 * exactly(unsigned int times)

If the order of invocation is concerned, *before()*, *after()* and *id()* could be used.

Followed is an example:
{{{

mockObject->method("foo")
   .expects(once())
   .will(returnValue(100))
   .id("method-foo");


mockObject->method("bar")
   .expects(once())
   .after("method-foo");

}}}

As you've seen, parameters of them are all strings. There is no rules for naming an invocation, but it has to be unique.

If two or more invocations belong to different mock objects, you must make it clear in *before()* and *after()*:

{{{

mockObject1->method("foo")
   .expects(once())
   .will(returnValue(100))
   .id("method-foo");


mockObject2->method("bar")
   .expects(once())
   .after(mockObject1, "method-foo");

}}}